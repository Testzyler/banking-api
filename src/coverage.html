
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>entities: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Testzyler/banking-api/app/entities/auth.go (0.0%)</option>
				
				<option value="file1">github.com/Testzyler/banking-api/app/entities/common.go (0.0%)</option>
				
				<option value="file2">github.com/Testzyler/banking-api/app/entities/user.go (0.0%)</option>
				
				<option value="file3">github.com/Testzyler/banking-api/app/features/auth/handler/auth_handler.go (83.3%)</option>
				
				<option value="file4">github.com/Testzyler/banking-api/app/features/auth/repository/auth_repository.go (79.2%)</option>
				
				<option value="file5">github.com/Testzyler/banking-api/app/features/auth/service/auth_service.go (93.7%)</option>
				
				<option value="file6">github.com/Testzyler/banking-api/app/features/auth/service/jwt_service.go (90.7%)</option>
				
				<option value="file7">github.com/Testzyler/banking-api/app/features/home/handler/home_handler.go (76.9%)</option>
				
				<option value="file8">github.com/Testzyler/banking-api/app/features/home/repository/home_repository.go (70.5%)</option>
				
				<option value="file9">github.com/Testzyler/banking-api/app/features/home/service/home_service.go (100.0%)</option>
				
				<option value="file10">github.com/Testzyler/banking-api/app/models/account.go (0.0%)</option>
				
				<option value="file11">github.com/Testzyler/banking-api/app/models/banner.go (0.0%)</option>
				
				<option value="file12">github.com/Testzyler/banking-api/app/models/debit_card.go (0.0%)</option>
				
				<option value="file13">github.com/Testzyler/banking-api/app/models/transaction.go (0.0%)</option>
				
				<option value="file14">github.com/Testzyler/banking-api/app/models/user.go (0.0%)</option>
				
				<option value="file15">github.com/Testzyler/banking-api/app/validators/validator.go (75.8%)</option>
				
				<option value="file16">github.com/Testzyler/banking-api/cmd/cmd.go (0.0%)</option>
				
				<option value="file17">github.com/Testzyler/banking-api/cmd/migrate.go (0.0%)</option>
				
				<option value="file18">github.com/Testzyler/banking-api/cmd/serve_api.go (0.0%)</option>
				
				<option value="file19">github.com/Testzyler/banking-api/config/config.go (0.0%)</option>
				
				<option value="file20">github.com/Testzyler/banking-api/database/database.go (0.0%)</option>
				
				<option value="file21">github.com/Testzyler/banking-api/database/migrations/001_add_mock_data.go (0.0%)</option>
				
				<option value="file22">github.com/Testzyler/banking-api/database/migrations/002_create_user_pin.go (0.0%)</option>
				
				<option value="file23">github.com/Testzyler/banking-api/database/migrations/003_create_index.go (0.0%)</option>
				
				<option value="file24">github.com/Testzyler/banking-api/database/migrations/004_delete_un_used_columns.go (0.0%)</option>
				
				<option value="file25">github.com/Testzyler/banking-api/database/mysql.go (12.5%)</option>
				
				<option value="file26">github.com/Testzyler/banking-api/database/redis.go (65.0%)</option>
				
				<option value="file27">github.com/Testzyler/banking-api/logger/logger.go (0.0%)</option>
				
				<option value="file28">github.com/Testzyler/banking-api/main.go (0.0%)</option>
				
				<option value="file29">github.com/Testzyler/banking-api/server/exception/errors.go (0.0%)</option>
				
				<option value="file30">github.com/Testzyler/banking-api/server/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file31">github.com/Testzyler/banking-api/server/middlewares/error_handler.go (0.0%)</option>
				
				<option value="file32">github.com/Testzyler/banking-api/server/middlewares/middleware.go (0.0%)</option>
				
				<option value="file33">github.com/Testzyler/banking-api/server/response/response.go (0.0%)</option>
				
				<option value="file34">github.com/Testzyler/banking-api/server/response/response_code.go (0.0%)</option>
				
				<option value="file35">github.com/Testzyler/banking-api/server/routes/route.go (0.0%)</option>
				
				<option value="file36">github.com/Testzyler/banking-api/server/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package entities

import (
        "time"

        "github.com/Testzyler/banking-api/app/validators"
        "github.com/golang-jwt/jwt/v5"
)

type PinVerifyParams struct {
        Username string `json:"username"`
        Pin      string `json:"pin" validate:"required,min=6,max=6,numeric"`
}

func (p *PinVerifyParams) Validate() error <span class="cov0" title="0">{
        return validators.ValidateStruct(p)
}</span>

type RefreshTokenRequest struct {
        RefreshToken string `json:"refreshToken" validate:"required"`
}

type TokenResponse struct {
        Token        string    `json:"token"`
        Expiry       time.Time `json:"expiry"`
        RefreshToken string    `json:"refreshToken"`
        UserID       string    `json:"userID"`
        TokenVersion int64     `json:"tokenVersion"` // Track when token was issued (timestamp)
        TokenID      string    `json:"tokenID"`      // Unique token identifier
}

type Claims struct {
        UserID       string `json:"userID"`
        Username     string `json:"username"`
        Type         string `json:"type" validate:"required,oneof=access refresh"`
        TokenVersion int64  `json:"tokenVersion"` // Track when token was issued (timestamp)
        TokenID      string `json:"tokenID"`      // Unique token identifier
        jwt.RegisteredClaims
}

type BannedToken struct {
        TokenID      string    `json:"tokenID"`
        UserID       string    `json:"userID"`
        Token        string    `json:"token"`
        BannedAt     time.Time `json:"bannedAt"`
        Reason       string    `json:"reason,omitempty"`
        TokenVersion int64     `json:"tokenVersion"`
}

type TokenValidationResult struct {
        Valid        bool   `json:"valid"`
        Reason       string `json:"reason,omitempty"`
        TokenVersion int64  `json:"tokenVersion"`
        Claims       Claims `json:"claims,omitempty"`
}

type PinAttemptData struct {
        UserID         string     `json:"userID"`
        FailedAttempts int        `json:"failedAttempts"`
        PinLockedUntil *time.Time `json:"pinLockedUntil,omitempty"`
        LastAttemptAt  *time.Time `json:"lastAttemptAt,omitempty"`
}

type BanTokensRequest struct {
        UserID string `json:"userID" validate:"required"`
}

func (b *BanTokensRequest) Validate() error <span class="cov0" title="0">{
        return validators.ValidateStruct(b)
}</span>

type GenerateTokenParams struct {
        UserID       string
        Username     string
        TokenVersion int64
        TokenID      string
        TokenType    string
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package entities

import (
        "github.com/Testzyler/banking-api/app/validators"
        "github.com/Testzyler/banking-api/server/response"
)

type PaginationParams struct {
        PerPage int    `json:"perPage" query:"perPage" validate:"required,min=1,max=100"`
        Page    int    `json:"page" query:"page" validate:"required,min=1"`
        Search  string `json:"search" query:"search" validate:"max=255"`
}

func (p *PaginationParams) Validate() error <span class="cov0" title="0">{
        return validators.ValidateStruct(p)
}</span>

type PaginatedResponse struct {
        response.SuccessResponse
        Meta PaginationMeta `json:"meta"`
}

type PaginationMeta struct {
        Page        int  `json:"page"`
        PerPage     int  `json:"perPage"`
        Total       int  `json:"total"`
        TotalPages  int  `json:"totalPages"`
        HasNext     bool `json:"hasNext"`
        HasPrevious bool `json:"hasPrevious"`
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package entities

import (
        "time"

        "github.com/Testzyler/banking-api/app/validators"
)

type GetUserByIdParams struct {
        UserID string `json:"user_id" validate:"required,min=3,max=50"`
}

func (p *GetUserByIdParams) Validate() error <span class="cov0" title="0">{
        return validators.ValidateStruct(p)
}</span>

type User struct {
        UserID   string  `json:"userID"`
        Name     string  `json:"name"`
        Greeting string  `json:"greeting,omitempty"`
        UserPin  UserPin `json:"user_pin"`
}

type UserPin struct {
        HashedPin         string    `json:"hashed_pin"`
        FailedPinAttempts int       `json:"failed_pin_attempts"`
        PinLockedUntil    time.Time `json:"pin_locked_until"`
        LastPinAttemptAt  time.Time `json:"last_pin_attempt_at"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/features/auth/service"
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/Testzyler/banking-api/server/response"
        "github.com/gofiber/fiber/v2"
)

type authHandler struct {
        service service.AuthService
}

func NewAuthHandler(router fiber.Router, service service.AuthService) <span class="cov0" title="0">{
        handler := &amp;authHandler{
                service: service,
        }

        auth := router.Group("/auth")
        auth.Post("/verify-pin", handler.VerifyPin)
        auth.Post("/refresh", handler.RefreshToken)
        auth.Get("/tokens", handler.ListAllTokens)
        auth.Post("/ban-tokens", handler.BanAllUserTokens)
}</span>

func (h *authHandler) ListAllTokens(c *fiber.Ctx) error <span class="cov8" title="1">{
        tokens, err := h.service.ListTokens(c.Context())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(&amp;response.SuccessResponse{
                Code:    response.Success,
                Message: "Tokens retrieved successfully",
                Data:    tokens,
        })</span>
}

func (h *authHandler) VerifyPin(c *fiber.Ctx) error <span class="cov8" title="1">{
        var params entities.PinVerifyParams
        if err := c.BodyParser(&amp;params); err != nil </span><span class="cov8" title="1">{
                return exception.ErrValidationFailed
        }</span>

        <span class="cov8" title="1">if err := params.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">tokenResponse, err := h.service.VerifyPin(c.Context(), params)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(&amp;response.SuccessResponse{
                Code:    response.Success,
                Message: "PIN verified successfully",
                Data:    tokenResponse,
        })</span>
}

func (h *authHandler) RefreshToken(c *fiber.Ctx) error <span class="cov8" title="1">{
        var req entities.RefreshTokenRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(response.ErrorResponse{
                        Code:    response.ErrCodeBadRequest,
                        Message: "Invalid request body",
                        Details: err.Error(),
                })
        }</span>

        <span class="cov8" title="1">tokenResponse, err := h.service.RefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov8" title="1">{
                if errorResponse, ok := err.(*response.ErrorResponse); ok </span><span class="cov8" title="1">{
                        return c.Status(errorResponse.HttpStatusCode).JSON(errorResponse)
                }</span>

                <span class="cov8" title="1">return c.Status(fiber.StatusUnauthorized).JSON(response.ErrorResponse{
                        Code:    response.ErrCodeUnauthorized,
                        Message: "Invalid refresh token",
                        Details: err.Error(),
                })</span>
        }

        <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(response.SuccessResponse{
                Code:    response.Success,
                Message: "Token refreshed successfully",
                Data:    tokenResponse,
        })</span>
}

func (h *authHandler) BanAllUserTokens(c *fiber.Ctx) error <span class="cov8" title="1">{
        var req entities.BanTokensRequest
        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(response.ErrorResponse{
                        Code:    response.ErrCodeBadRequest,
                        Message: "User ID is required",
                })
        }</span>

        <span class="cov8" title="1">if err := h.service.BanToken(c.Context(), req.UserID); err != nil </span><span class="cov8" title="1">{
                if errorResponse, ok := err.(*response.ErrorResponse); ok </span><span class="cov8" title="1">{
                        return c.Status(errorResponse.HttpStatusCode).JSON(errorResponse)
                }</span>
                <span class="cov8" title="1">return c.Status(fiber.StatusInternalServerError).JSON(response.ErrorResponse{
                        Code:    response.ErrCodeInternalServer,
                        Message: "Failed to ban token",
                        Details: err.Error(),
                })</span>
        }

        <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(response.SuccessResponse{
                Code:    response.Success,
                Message: "Token banned successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/models"
        "github.com/Testzyler/banking-api/database"
        "github.com/Testzyler/banking-api/logger"
        "github.com/redis/go-redis/v9"
        "gorm.io/gorm"
)

type authRepository struct {
        db          *gorm.DB
        redisClient redis.Cmdable
}

type AuthRepository interface {
        // Redis
        GetPinAttemptData(ctx context.Context, userID string) (*entities.PinAttemptData, error)
        IncrementFailedAttempts(ctx context.Context, userID string) (*entities.PinAttemptData, error)
        SetPinLock(ctx context.Context, userID string, lockedUntil time.Time, failedAttempts int, lastAttemptAt *time.Time) error
        ResetPinAttempts(ctx context.Context, userID string) error
        ListUserTokens(ctx context.Context) ([]entities.TokenResponse, error)
        StoreToken(ctx context.Context, userID string, tokenResponse *entities.TokenResponse) error
        BanAllUserTokens(ctx context.Context, userID, reason string) error
        IsTokenBanned(ctx context.Context, tokenID string) (bool, error)
        ValidateTokenVersion(ctx context.Context, tokenVersion int64) (*entities.TokenValidationResult, error)
        CleanupExpiredBans(ctx context.Context) error

        // database
        GetUserWithPin(username string) (*models.User, error)
        UpdateUserPinFailedAttempts(userID string, failedAttempts int) error
        UpdateUserPinLockedUntil(userID string, lockedUntil *time.Time) error
        UpdateUserPinLastAttemptAt(userID string, lastAttemptAt *time.Time) error
}

func NewAuthRepository(db *gorm.DB, redisDB *database.RedisDatabase) AuthRepository <span class="cov8" title="1">{
        var redisClient redis.Cmdable
        if redisDB != nil </span><span class="cov8" title="1">{
                redisClient = redisDB.GetClient()
        }</span>

        <span class="cov8" title="1">return &amp;authRepository{
                db:          db,
                redisClient: redisClient,
        }</span>
}

// Redis helper methods
func (r *authRepository) pinAttemptKey(userID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("pin_attempt:%s", userID)
}</span>

func (r *authRepository) bannedTokenKey(tokenID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("banned_token:%s", tokenID)
}</span>

func (r *authRepository) userTokensKey(userID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("user_tokens:%s", userID)
}</span>


func (r *authRepository) invalidateUserCacheByID(userID string) <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">userTokensKey := r.userTokensKey(userID)
        _ = r.redisClient.Del(context.Background(), userTokensKey).Err()</span>
}

func (r *authRepository) GetUserWithPin(username string) (*models.User, error) <span class="cov8" title="1">{
        ctx := context.Background()

        if r.redisClient != nil </span><span class="cov8" title="1">{
                cacheKey := fmt.Sprintf("user_with_pin:%s", username)
                result, err := r.redisClient.Get(ctx, cacheKey).Result()
                if err == nil </span><span class="cov8" title="1">{
                        var user models.User
                        if err := json.Unmarshal([]byte(result), &amp;user); err == nil </span><span class="cov8" title="1">{
                                return &amp;user, nil
                        }</span>
                }
        }

        // Fetch from database
        <span class="cov8" title="1">var user models.User
        err := r.db.
                Preload("UserPin").
                Where("name = ?", username).
                First(&amp;user).Error

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Store in Redis cache for future requests (async)
        <span class="cov8" title="1">if r.redisClient != nil </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        cacheKey := fmt.Sprintf("user_with_pin:%s", username)
                        userJSON, err := json.Marshal(user)
                        if err == nil </span><span class="cov8" title="1">{
                                _ = r.redisClient.Set(ctx, cacheKey, string(userJSON), 30*time.Minute).Err()
                        }</span>
                }()
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *authRepository) GetPinAttemptData(ctx context.Context, userID string) (*entities.PinAttemptData, error) <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return &amp;entities.PinAttemptData{UserID: userID, FailedAttempts: 0}, nil
        }</span>

        <span class="cov8" title="1">key := r.pinAttemptKey(userID)
        result, err := r.redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov8" title="1">{
                if err == redis.Nil </span><span class="cov8" title="1">{
                        return &amp;entities.PinAttemptData{UserID: userID, FailedAttempts: 0}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get pin attempt data from Redis: %w", err)</span>
        }

        <span class="cov8" title="1">var data entities.PinAttemptData
        if err := json.Unmarshal([]byte(result), &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal pin attempt data: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;data, nil</span>
}

func (r *authRepository) setPinAttemptData(ctx context.Context, userID string, data *entities.PinAttemptData, ttl time.Duration) error <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">key := r.pinAttemptKey(userID)
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal pin attempt data: %w", err)
        }</span>

        <span class="cov8" title="1">return r.redisClient.Set(ctx, key, string(jsonData), ttl).Err()</span>
}

func (r *authRepository) IncrementFailedAttempts(ctx context.Context, userID string) (*entities.PinAttemptData, error) <span class="cov8" title="1">{
        data, err := r.GetPinAttemptData(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to get pin attempt data from Redis, falling back to database", "error", err)

                // Fallback to database-only approach
                user, errInner := r.GetUserWithPin(userID)
                if errInner != nil </span><span class="cov0" title="0">{
                        return nil, errInner
                }</span>
                <span class="cov0" title="0">data = &amp;entities.PinAttemptData{
                        UserID:         userID,
                        FailedAttempts: user.UserPin.FailedPinAttempts,
                        PinLockedUntil: user.UserPin.PinLockedUntil,
                        LastAttemptAt:  user.UserPin.LastPinAttemptAt,
                }</span>
        }

        <span class="cov8" title="1">data.FailedAttempts++
        now := time.Now()
        data.LastAttemptAt = &amp;now

        // Set Redis immediately
        ttl := 24 * time.Hour
        if err := r.setPinAttemptData(ctx, userID, data, ttl); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Async database sync
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if err := r.UpdateUserPinFailedAttempts(userID, data.FailedAttempts); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to sync failed attempts to database for user %s: %v", userID, err)
                }</span> else<span class="cov0" title="0"> if err := r.UpdateUserPinLastAttemptAt(userID, data.LastAttemptAt); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to sync last attempt time to database for user %s: %v", userID, err)
                }</span> else<span class="cov0" title="0"> {
                        logger.Infof("Successfully synced failed attempts to database for user %s", userID)
                }</span>
        }()

        <span class="cov8" title="1">return data, nil</span>
}

func (r *authRepository) SetPinLock(ctx context.Context, userID string, lockedUntil time.Time, failedAttempts int, lastAttemptAt *time.Time) error <span class="cov8" title="1">{
        data, err := r.GetPinAttemptData(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">data.PinLockedUntil = &amp;lockedUntil
        data.FailedAttempts = failedAttempts
        data.LastAttemptAt = lastAttemptAt

        // update database async
        go func() </span><span class="cov8" title="1">{
                data, err := r.GetPinAttemptData(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to get pin attempt data for user %s: %v", userID, err)
                }</span>
                <span class="cov8" title="1">if data.FailedAttempts &gt; 0 || data.PinLockedUntil != nil || data.LastAttemptAt != nil </span><span class="cov0" title="0">{
                        if err := r.UpdateUserPinFailedAttempts(userID, 0); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset attempts in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> if err := r.UpdateUserPinLockedUntil(userID, nil); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset lock in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> if err := r.UpdateUserPinLastAttemptAt(userID, nil); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset last attempt time in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Infof("Successfully reset PIN attempts in database for user %s", userID)
                        }</span>
                }
        }()

        // Set Redis immediately
        <span class="cov8" title="1">ttl := time.Until(lockedUntil) + time.Hour
        if err := r.setPinAttemptData(ctx, userID, data, ttl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *authRepository) ResetPinAttempts(ctx context.Context, userID string) error <span class="cov8" title="1">{
        data := &amp;entities.PinAttemptData{
                UserID:         userID,
                FailedAttempts: 0,
                PinLockedUntil: nil,
                LastAttemptAt:  nil,
        }

        // Async database sync
        go func() </span><span class="cov8" title="1">{
                data, err := r.GetPinAttemptData(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Failed to get pin attempt data for user %s: %v", userID, err)
                }</span>
                <span class="cov8" title="1">if data.FailedAttempts &gt; 0 || data.PinLockedUntil != nil || data.LastAttemptAt != nil </span><span class="cov0" title="0">{
                        if err := r.UpdateUserPinFailedAttempts(userID, 0); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset attempts in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> if err := r.UpdateUserPinLockedUntil(userID, nil); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset lock in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> if err := r.UpdateUserPinLastAttemptAt(userID, nil); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to reset last attempt time in database for user %s: %v", userID, err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Infof("Successfully reset PIN attempts in database for user %s", userID)
                        }</span>
                }
        }()

        // Set Redis immediately
        <span class="cov8" title="1">ttl := time.Hour
        if err := r.setPinAttemptData(ctx, userID, data, ttl); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *authRepository) BanAllUserTokens(ctx context.Context, userID, reason string) error <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Redis client is not initialized")
        }</span>

        // Get all user tokens
        <span class="cov8" title="1">userTokensKey := r.userTokensKey(userID)
        tokens, err := r.redisClient.SMembers(ctx, userTokensKey).Result()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get user tokens: %w", err)
        }</span>

        // Ban each token individually
        <span class="cov8" title="1">for _, tokenStr := range tokens </span><span class="cov8" title="1">{
                var tokenResponse entities.TokenResponse
                if err := json.Unmarshal([]byte(tokenStr), &amp;tokenResponse); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to unmarshal token for banning: %v", err)
                        continue</span>
                }

                <span class="cov8" title="1">if err := r.banToken(ctx, userID, tokenResponse.TokenID, reason); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to ban token %s: %v", tokenResponse.TokenID, err)
                }</span>
        }

        <span class="cov8" title="1">logger.Infof("All tokens banned for user %s: %s", userID, reason)
        return nil</span>
}

func (r *authRepository) banToken(ctx context.Context, userID, tokenID, reason string) error <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Redis client is not initialized")
        }</span>

        <span class="cov8" title="1">bannedToken := entities.BannedToken{
                TokenID:      tokenID,
                UserID:       userID,
                BannedAt:     time.Now(),
                Reason:       reason,
                TokenVersion: time.Now().Unix(), // Use current timestamp as version
        }
        r.invalidateUserCacheByID(userID)
        bannedKey := r.bannedTokenKey(tokenID)
        bannedData, err := json.Marshal(bannedToken)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal banned token data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := r.redisClient.Set(ctx, bannedKey, string(bannedData), 24*time.Hour).Err(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to store banned token in Redis: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *authRepository) IsTokenBanned(ctx context.Context, tokenID string) (bool, error) <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return true, nil // If Redis is not available, assume token is banned user input pin
        }</span>

        <span class="cov8" title="1">bannedKey := r.bannedTokenKey(tokenID)
        result, err := r.redisClient.Get(ctx, bannedKey).Result()
        if err != nil </span><span class="cov8" title="1">{
                if err == redis.Nil </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("failed to check banned token: %w", err)</span>
        }

        // Token exists in banned list
        <span class="cov8" title="1">return result != "", nil</span>
}

func (r *authRepository) ValidateTokenVersion(ctx context.Context, tokenVersion int64) (*entities.TokenValidationResult, error) <span class="cov8" title="1">{
        // Token version is based on issued timestamp
        // Check if token is too old (older than 24 hours for example)
        currentTime := time.Now().Unix()
        maxAge := int64(24 * 60 * 60) // 24 hours in seconds

        if tokenVersion &lt; (currentTime - maxAge) </span><span class="cov8" title="1">{
                return &amp;entities.TokenValidationResult{
                        Valid:        false,
                        Reason:       "Token is too old",
                        TokenVersion: currentTime,
                }, nil
        }</span>

        <span class="cov8" title="1">return &amp;entities.TokenValidationResult{
                Valid:        true,
                TokenVersion: currentTime,
        }, nil</span>
}

func (r *authRepository) CleanupExpiredBans(ctx context.Context) error <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var cursor uint64
        for </span><span class="cov8" title="1">{
                keys, nextCursor, err := r.redisClient.Scan(ctx, cursor, "banned_token:*", 100).Result()
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to scan banned tokens: %w", err)
                }</span>

                <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                        // Check if key exists (Redis TTL will auto-expire keys)
                        exists, err := r.redisClient.Exists(ctx, key).Result()
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to check key existence: %v", err)
                                continue</span>
                        }
                        <span class="cov8" title="1">if exists == 0 </span><span class="cov8" title="1">{
                                logger.Debugf("Banned token key %s has expired", key)
                        }</span>
                }

                <span class="cov8" title="1">cursor = nextCursor
                if cursor == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *authRepository) StoreToken(ctx context.Context, userID string, tokenResponse *entities.TokenResponse) error <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Redis client is not initialized")
        }</span>

        <span class="cov8" title="1">key := r.userTokensKey(userID)
        tokenJSON, err := json.Marshal(tokenResponse)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal token response: %w", err)
        }</span>

        // Store token in the user's token set
        <span class="cov8" title="1">if err := r.redisClient.SAdd(ctx, key, string(tokenJSON)).Err(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to store token in Redis: %w", err)
        }</span>

        // Set expiry for the key based on token expiry
        <span class="cov8" title="1">if !tokenResponse.Expiry.IsZero() </span><span class="cov0" title="0">{
                ttl := time.Until(tokenResponse.Expiry)
                if ttl &gt; 0 </span><span class="cov0" title="0">{
                        if err := r.redisClient.Expire(ctx, key, ttl).Err(); err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to set expiry for token key %s: %v", key, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *authRepository) ListUserTokens(ctx context.Context) ([]entities.TokenResponse, error) <span class="cov8" title="1">{
        if r.redisClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Redis client is not initialized")
        }</span>

        <span class="cov8" title="1">var allTokenResponses []entities.TokenResponse
        var cursor uint64

        for </span><span class="cov8" title="1">{
                keys, nextCursor, err := r.redisClient.Scan(ctx, cursor, "user_tokens:*", 100).Result()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to scan token keys from Redis: %w", err)
                }</span>

                // Process found keys
                <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                        userID := key[len("user_tokens:"):]
                        tokens, err := r.redisClient.SMembers(ctx, key).Result()
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("Failed to get tokens for user %s: %v", userID, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, tokenStr := range tokens </span><span class="cov8" title="1">{
                                var tokenResponse entities.TokenResponse
                                if err := json.Unmarshal([]byte(tokenStr), &amp;tokenResponse); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("Failed to unmarshal token for user %s: %v", userID, err)
                                        continue</span>
                                }
                                <span class="cov8" title="1">allTokenResponses = append(allTokenResponses, tokenResponse)</span>
                        }
                }

                <span class="cov8" title="1">cursor = nextCursor
                if cursor == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return allTokenResponses, nil</span>
}

// Legacy database-only methods for fallback
func (r *authRepository) UpdateUserPinFailedAttempts(userID string, failedAttempts int) error <span class="cov8" title="1">{
        return r.db.Model(&amp;models.UserPin{}).Where("user_id = ?", userID).Update("failed_pin_attempts", failedAttempts).Error
}</span>

func (r *authRepository) UpdateUserPinLockedUntil(userID string, lockedUntil *time.Time) error <span class="cov8" title="1">{
        return r.db.Model(&amp;models.UserPin{}).Where("user_id = ?", userID).Update("pin_locked_until", lockedUntil).Error
}</span>

func (r *authRepository) UpdateUserPinLastAttemptAt(userID string, lastAttemptAt *time.Time) error <span class="cov8" title="1">{
        return r.db.Model(&amp;models.UserPin{}).Where("user_id = ?", userID).Update("last_pin_attempt_at", lastAttemptAt).Error
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/features/auth/repository"
        "github.com/Testzyler/banking-api/app/models"
        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/logger"
        "github.com/Testzyler/banking-api/server/exception"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type authService struct {
        config     *config.Config
        jwtService JwtService
        repository repository.AuthRepository
}

type AuthService interface {
        VerifyPin(ctx context.Context, params entities.PinVerifyParams) (*entities.TokenResponse, error)
        RefreshToken(refreshToken string) (*entities.TokenResponse, error)
        ListTokens(ctx context.Context) ([]entities.TokenResponse, error)
        BanToken(ctx context.Context, userID string) error
}

func NewAuthService(repository repository.AuthRepository, jwtService JwtService, config *config.Config) AuthService <span class="cov8" title="1">{
        return &amp;authService{repository: repository, jwtService: jwtService, config: config}
}</span>

func (s *authService) ListTokens(ctx context.Context) ([]entities.TokenResponse, error) <span class="cov8" title="1">{
        tokens, err := s.repository.ListUserTokens(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return tokens, nil</span>
}

func (s *authService) VerifyPin(ctx context.Context, params entities.PinVerifyParams) (*entities.TokenResponse, error) <span class="cov8" title="1">{
        user, err := s.repository.GetUserWithPin(params.Username)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, exception.ErrUserNotFound
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">now := time.Now()
        // Check Redis cache
        cacheData, err := s.repository.GetPinAttemptData(ctx, user.UserID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to get cache data for user %s: %v", user.UserID, err)
                cacheData = &amp;entities.PinAttemptData{
                        UserID:         user.UserID,
                        FailedAttempts: user.UserPin.FailedPinAttempts,
                        PinLockedUntil: user.UserPin.PinLockedUntil,
                        LastAttemptAt:  user.UserPin.LastPinAttemptAt,
                }
        }</span>

        <span class="cov8" title="1">if isLocked, remainingTime := isPinLocked(cacheData, now); isLocked </span><span class="cov8" title="1">{
                return nil, exception.NewPinLockedError(remainingTime.String())
        }</span>

        <span class="cov8" title="1">if !isPinCorrect(user.UserPin.HashedPin, params.Pin) </span><span class="cov8" title="1">{
                return nil, s.handleFailedAttempt(ctx, user, now)
        }</span>

        <span class="cov8" title="1">if err := s.repository.ResetPinAttempts(ctx, user.UserID); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to reset cache attempts for user %s: %v", user.UserID, err)
        }</span>

        // Generate JWT tokens with token version (timestamp)
        <span class="cov8" title="1">tokenResponse, err := s.jwtService.GenerateTokens(user.UserID, params.Username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.NewInternalError(err)
        }</span>

        // Store token in Redis for tracking
        <span class="cov8" title="1">tokenResponse.UserID = user.UserID
        if err := s.repository.StoreToken(ctx, user.UserID, tokenResponse); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to store token in Redis for user %s: %v", user.UserID, err)
        }</span>

        <span class="cov8" title="1">return tokenResponse, nil</span>
}

func isPinLocked(cacheData *entities.PinAttemptData, now time.Time) (bool, time.Duration) <span class="cov8" title="1">{
        if cacheData.PinLockedUntil != nil &amp;&amp; now.Before(*cacheData.PinLockedUntil) </span><span class="cov8" title="1">{
                remainingTime := cacheData.PinLockedUntil.Sub(now).Round(time.Second)
                return true, remainingTime
        }</span>
        <span class="cov8" title="1">return false, 0</span>
}

func isPinCorrect(hashedPin, inputPin string) bool <span class="cov8" title="1">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPin), []byte(inputPin)) == nil
}</span>

func (s *authService) handleFailedAttempt(ctx context.Context, user *models.User, now time.Time) error <span class="cov8" title="1">{
        cacheData, err := s.repository.IncrementFailedAttempts(ctx, user.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">baseDuration := s.config.Auth.Pin.BaseDuration
        lockThreshold := s.config.Auth.Pin.LockThreshold
        maxLockDuration := s.config.Auth.Pin.MaxLockDuration

        if cacheData.FailedAttempts &gt;= lockThreshold </span><span class="cov8" title="1">{
                power := cacheData.FailedAttempts - lockThreshold
                lockDuration := baseDuration * time.Duration(1&lt;&lt;power) // 2^power

                // Cap max lock duration
                if lockDuration &gt; maxLockDuration </span><span class="cov8" title="1">{
                        lockDuration = maxLockDuration
                }</span>

                <span class="cov8" title="1">lockedUntil := now.Add(lockDuration)

                // Set lock in Redis immediately, then async DB sync
                if err := s.repository.SetPinLock(ctx, user.UserID, lockedUntil, cacheData.FailedAttempts, cacheData.LastAttemptAt); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Failed to set pin lock in cache for user %s: %v", user.UserID, err)
                }</span>

                <span class="cov8" title="1">return exception.NewPinLockedError(lockDuration.String())</span>
        }

        <span class="cov8" title="1">remainingAttempts := lockThreshold - cacheData.FailedAttempts
        return exception.NewInvalidPinError(remainingAttempts)</span>
}

func (s *authService) RefreshToken(refreshToken string) (*entities.TokenResponse, error) <span class="cov8" title="1">{
        tokenResponse, err := s.jwtService.RefreshAccessToken(refreshToken)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Store the new token in Redis for tracking
        <span class="cov8" title="1">if tokenResponse.UserID != "" </span><span class="cov8" title="1">{
                ctx := context.Background()
                if err := s.repository.StoreToken(ctx, tokenResponse.UserID, tokenResponse); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store refreshed token in Redis for user %s: %v", tokenResponse.UserID, err)
                }</span>
        }

        <span class="cov8" title="1">return tokenResponse, nil</span>
}

func (s *authService) BanToken(ctx context.Context, userID string) error <span class="cov8" title="1">{
        reason := "Manually banned by admin"
        if err := s.repository.BanAllUserTokens(ctx, userID, reason); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">logger.Infof("User %s has been banned all tokens successfully", userID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package service

import (
        "context"
        "errors"
        "time"

        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/features/auth/repository"
        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/logger"
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type jwtService struct {
        config   *config.Config
        authRepo repository.AuthRepository
}

type JwtService interface {
        GenerateTokens(userID, username string) (*entities.TokenResponse, error)
        ValidateAccessToken(tokenString string) (*entities.Claims, error)
        ValidateRefreshToken(tokenString string) (*entities.Claims, error)
        RefreshAccessToken(refreshTokenString string) (*entities.TokenResponse, error)
        ValidateTokenWithBanCheck(tokenString string) (*entities.TokenValidationResult, error)
}

func NewJwtService(config *config.Config, authRepo repository.AuthRepository) JwtService <span class="cov8" title="1">{
        return &amp;jwtService{config: config, authRepo: authRepo}
}</span>

func (s *jwtService) GenerateTokens(userID, username string) (*entities.TokenResponse, error) <span class="cov8" title="1">{
        // Generate unique token ID and use current timestamp as token version
        tokenID := uuid.New().String()
        tokenVersion := time.Now().Unix()
        accessTokenParam := entities.GenerateTokenParams{
                UserID:       userID,
                Username:     username,
                TokenVersion: tokenVersion,
                TokenID:      tokenID,
                TokenType:    "access",
        }
        accessToken, accessExpiry, err := s.generateToken(accessTokenParam)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">refreshTokenID := uuid.New().String()
        refreshTokenParam := entities.GenerateTokenParams{
                UserID:       userID,
                Username:     username,
                TokenVersion: tokenVersion,
                TokenID:      refreshTokenID,
                TokenType:    "refresh",
        }
        refreshToken, _, err := s.generateToken(refreshTokenParam)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;entities.TokenResponse{
                Token:        accessToken,
                Expiry:       accessExpiry,
                RefreshToken: refreshToken,
                TokenVersion: tokenVersion,
                TokenID:      tokenID,
        }, nil</span>
}

func (s *jwtService) generateToken(param entities.GenerateTokenParams) (string, time.Time, error) <span class="cov8" title="1">{
        var secret string
        var expiry time.Duration

        switch param.TokenType </span>{
        case "access":<span class="cov8" title="1">
                secret = s.config.Auth.Jwt.AccessTokenSecret
                expiry = s.config.Auth.Jwt.AccessTokenExpiry</span>
        case "refresh":<span class="cov8" title="1">
                secret = s.config.Auth.Jwt.RefreshTokenSecret
                expiry = s.config.Auth.Jwt.RefreshTokenExpiry</span>
        default:<span class="cov8" title="1">
                return "", time.Time{}, errors.New("invalid token type")</span>
        }

        <span class="cov8" title="1">now := time.Now()
        expiryTime := now.Add(expiry)

        claims := &amp;entities.Claims{
                UserID:       param.UserID,
                Username:     param.Username,
                Type:         param.TokenType,
                TokenVersion: param.TokenVersion,
                TokenID:      param.TokenID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ID:        param.TokenID,
                        Subject:   param.UserID,
                        Audience:  []string{"banking-api"},
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(expiryTime),
                        Issuer:    "banking-api",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, err
        }</span>

        <span class="cov8" title="1">return tokenString, expiryTime, nil</span>
}

func (s *jwtService) ValidateAccessToken(tokenString string) (*entities.Claims, error) <span class="cov8" title="1">{
        return s.validateToken(tokenString, s.config.Auth.Jwt.AccessTokenSecret, "access")
}</span>

func (s *jwtService) ValidateRefreshToken(tokenString string) (*entities.Claims, error) <span class="cov8" title="1">{
        return s.validateToken(tokenString, s.config.Auth.Jwt.RefreshTokenSecret, "refresh")
}</span>

func (s *jwtService) validateToken(tokenString, secret, expectedType string) (*entities.Claims, error) <span class="cov8" title="1">{
        if tokenString == "" </span><span class="cov8" title="1">{
                return nil, errors.New("token is empty")
        }</span>

        <span class="cov8" title="1">token, err := jwt.ParseWithClaims(tokenString, &amp;entities.Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov8" title="1">return []byte(secret), nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, jwt.ErrTokenExpired) </span><span class="cov8" title="1">{
                        return nil, exception.ErrTokenExpired
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">if claims, ok := token.Claims.(*entities.Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                if claims.Type != expectedType </span><span class="cov0" title="0">{
                        return nil, jwt.ErrInvalidType
                }</span>
                <span class="cov8" title="1">return claims, nil</span>
        }

        <span class="cov0" title="0">return nil, jwt.ErrTokenInvalidClaims</span>
}

func (s *jwtService) RefreshAccessToken(refreshTokenString string) (*entities.TokenResponse, error) <span class="cov8" title="1">{
        claims, err := s.ValidateRefreshToken(refreshTokenString)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newTokenID := uuid.New().String()
        newTokenVersion := time.Now().Unix()
        // Generate new access token
        accessTokenParam := entities.GenerateTokenParams{
                UserID:       claims.UserID,
                Username:     claims.Username,
                TokenVersion: newTokenVersion,
                TokenID:      newTokenID,
                TokenType:    "access",
        }
        accessToken, accessExpiry, err := s.generateToken(accessTokenParam)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;entities.TokenResponse{
                Token:        accessToken,
                Expiry:       accessExpiry,
                RefreshToken: refreshTokenString,
                UserID:       claims.UserID,
                TokenVersion: newTokenVersion,
                TokenID:      newTokenID,
        }, nil</span>
}

func (s *jwtService) ValidateTokenWithBanCheck(tokenString string) (*entities.TokenValidationResult, error) <span class="cov8" title="1">{
        claims, err := s.ValidateAccessToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;entities.TokenValidationResult{
                        Valid:        false,
                        Reason:       "invalid token",
                        TokenVersion: 0,
                }, err
        }</span>

        <span class="cov8" title="1">if s.authRepo == nil </span><span class="cov8" title="1">{
                return &amp;entities.TokenValidationResult{
                        Valid:        false,
                        Reason:       "Error: auth repository not initialized",
                        TokenVersion: claims.TokenVersion,
                }, nil
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        isBanned, err := s.authRepo.IsTokenBanned(ctx, claims.TokenID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to check if token is banned: %v", err)
                return &amp;entities.TokenValidationResult{
                        Valid:        true,
                        Reason:       "ban check failed",
                        TokenVersion: claims.TokenVersion,
                }, nil
        }</span>

        <span class="cov8" title="1">if isBanned </span><span class="cov8" title="1">{
                return &amp;entities.TokenValidationResult{
                        Valid:        false,
                        Reason:       "token is banned",
                        TokenVersion: claims.TokenVersion,
                }, exception.NewTokenBannedError()
        }</span>

        <span class="cov8" title="1">validationResult, err := s.authRepo.ValidateTokenVersion(ctx, claims.TokenVersion)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to validate token version: %v", err)
                return &amp;entities.TokenValidationResult{
                        Valid:        true,
                        Reason:       "version check failed",
                        TokenVersion: claims.TokenVersion,
                }, nil
        }</span>

        <span class="cov8" title="1">if !validationResult.Valid </span><span class="cov8" title="1">{
                return &amp;entities.TokenValidationResult{
                        Valid:        false,
                        Reason:       validationResult.Reason,
                        TokenVersion: claims.TokenVersion,
                }, exception.NewTokenOutdatedError(validationResult.Reason)
        }</span>

        <span class="cov8" title="1">return &amp;entities.TokenValidationResult{
                Valid:        true,
                Reason:       "",
                TokenVersion: claims.TokenVersion,
                Claims:       *claims,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/features/home/service"
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/Testzyler/banking-api/server/middlewares"
        "github.com/Testzyler/banking-api/server/response"
        "github.com/gofiber/fiber/v2"
)

type homeHandler struct {
        service service.HomeService
}

func NewHomeHandler(router fiber.Router, service service.HomeService) <span class="cov0" title="0">{
        handler := &amp;homeHandler{
                service: service,
        }

        home := router.Group("/home")
        home.Get("/", middlewares.AuthMiddleware(), handler.GetHomeData)
}</span>

func (h *homeHandler) GetHomeData(c *fiber.Ctx) error <span class="cov8" title="1">{
        userInterface := c.Locals("user")
        if userInterface == nil </span><span class="cov8" title="1">{
                return exception.ErrInternalServer
        }</span>

        <span class="cov8" title="1">user, ok := userInterface.(entities.Claims)
        if !ok </span><span class="cov8" title="1">{
                return exception.ErrInternalServer
        }</span>

        <span class="cov8" title="1">data, err := h.service.GetHomeData(user.UserID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.Status(fiber.StatusOK).JSON(&amp;response.SuccessResponse{
                Code:    response.Success,
                Message: "Home screen data retrieved successfully",
                Data:    data,
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package repository

import (
        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/models"
        "gorm.io/gorm"
)

type homeRepository struct {
        db *gorm.DB
}

type HomeRepository interface {
        GetTotalBalance(userID string) float64
        GetHomeData(userID string) (entities.HomeResponse, error)
}

func NewHomeRepository(repo *gorm.DB) HomeRepository <span class="cov8" title="1">{
        return &amp;homeRepository{
                db: repo,
        }
}</span>

func (r *homeRepository) GetTotalBalance(userID string) float64 <span class="cov8" title="1">{
        var total float64
        if err := r.db.Model(&amp;models.AccountBalance{}).
                Select("SUM(amount)").
                Joins("JOIN accounts ON account_balances.account_id = accounts.account_id").
                Where("accounts.user_id = ?", userID).
                Scan(&amp;total).Error; err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return total</span>
}

func (r *homeRepository) GetHomeData(userID string) (entities.HomeResponse, error) <span class="cov8" title="1">{
        var response entities.HomeResponse

        err := r.db.Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                // User + Greeting
                var user models.User
                if err := tx.Preload("UserGreeting").First(&amp;user, "user_id = ?", userID).Error; err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">response.UserID = user.UserID
                response.Name = user.Name
                if user.UserGreeting != nil </span><span class="cov0" title="0">{
                        response.Greeting = user.UserGreeting.Greeting
                }</span>

                // Debit Cards
                <span class="cov8" title="1">var cards []models.DebitCard
                if err := tx.Preload("DebitCardDetail").
                        Preload("DebitCardDesign").
                        Preload("DebitCardStatus").
                        Where("user_id = ?", userID).
                        Find(&amp;cards).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, c := range cards </span><span class="cov0" title="0">{
                        response.DebitCards = append(response.DebitCards, entities.DebitCards{
                                CardID:   c.CardID,
                                CardName: c.Name,
                                DebitCardDesign: entities.DebitCardDesign{
                                        Color:       c.DebitCardDesign.Color,
                                        BorderColor: c.DebitCardDesign.BorderColor,
                                },
                                Status:     c.DebitCardStatus.Status,
                                CardNumber: c.DebitCardDetail.Number,
                                Issuer:     c.DebitCardDetail.Issuer,
                        })
                }</span>

                // Banners
                <span class="cov8" title="1">var banners []models.Banner
                if err := tx.Find(&amp;banners, "user_id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, b := range banners </span><span class="cov0" title="0">{
                        response.Banners = append(response.Banners, entities.Banner{
                                BannerID:    b.BannerID,
                                UserID:      b.UserID,
                                Title:       b.Title,
                                Description: b.Description,
                                ImageURL:    b.Image,
                        })
                }</span>

                // Transactions
                <span class="cov8" title="1">var transactions []models.Transaction
                if err := tx.Find(&amp;transactions, "user_id = ?", userID).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, t := range transactions </span><span class="cov0" title="0">{
                        response.Transactions = append(response.Transactions, entities.Transaction{
                                TransactionID: t.TransactionID,
                                UserID:        t.UserID,
                                Name:          t.Name,
                                Image:         t.Image,
                                IsBank:        t.IsBank,
                        })
                }</span>

                // Accounts + preload related
                <span class="cov8" title="1">var accounts []models.Account
                if err := tx.Preload("AccountDetails").
                        Preload("AccountBalance").
                        Preload("AccountFlags").
                        Where("user_id = ?", userID).
                        Find(&amp;accounts).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">total := 0.0
                for _, acc := range accounts </span><span class="cov0" title="0">{
                        var flags []entities.AccountFlags
                        for _, f := range acc.AccountFlags </span><span class="cov0" title="0">{
                                flags = append(flags, entities.AccountFlags{
                                        FlagType:  f.FlagType,
                                        FlagValue: f.FlagValue,
                                        CreatedAt: f.CreatedAt,
                                        UpdatedAt: f.UpdatedAt,
                                })
                        }</span>
                        <span class="cov0" title="0">response.Accounts = append(response.Accounts, entities.Account{
                                AccountID: acc.AccountID,
                                Type:      acc.Type,
                                Currency:  acc.Currency,
                                Issuer:    acc.Issuer,
                                Amount:    acc.AccountBalance.Amount,
                                AccountDetails: entities.AccountDetails{
                                        Color:         acc.AccountDetails.Color,
                                        IsMainAccount: acc.AccountDetails.IsMainAccount,
                                        Progress:      acc.AccountDetails.Progress,
                                },
                                AccountFlags: flags,
                        })
                        total += acc.AccountBalance.Amount</span>
                }
                <span class="cov8" title="1">response.TotalBalance = total

                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return entities.HomeResponse{}, err
        }</span>
        <span class="cov8" title="1">return response, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "github.com/Testzyler/banking-api/app/entities"
        "github.com/Testzyler/banking-api/app/features/home/repository"
)

type homeService struct {
        repo repository.HomeRepository
}

type HomeService interface {
        GetHomeData(userID string) (entities.HomeResponse, error)
}

func NewHomeService(repo repository.HomeRepository) *homeService <span class="cov8" title="1">{
        return &amp;homeService{
                repo: repo,
        }
}</span>

func (s *homeService) GetHomeData(userID string) (entities.HomeResponse, error) <span class="cov8" title="1">{
        homeData, err := s.repo.GetHomeData(userID)
        if err != nil </span><span class="cov8" title="1">{
                return entities.HomeResponse{}, err
        }</span>

        <span class="cov8" title="1">return homeData, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import "time"

type Account struct {
        AccountID     string `gorm:"column:account_id;primaryKey"`
        UserID        string `gorm:"column:user_id"`
        Type          string `gorm:"column:type"`
        Currency      string `gorm:"column:currency"`
        AccountNumber string `gorm:"column:account_number"`
        Issuer        string `gorm:"column:issuer"`

        AccountDetails AccountDetail  `gorm:"foreignKey:AccountID"`
        AccountBalance AccountBalance `gorm:"foreignKey:AccountID"`
        AccountFlags   []AccountFlag  `gorm:"foreignKey:AccountID"`
}

func (Account) TableName() string <span class="cov0" title="0">{
        return "accounts"
}</span>

type AccountBalance struct {
        AccountID string  `gorm:"column:account_id;primaryKey"`
        UserID    string  `gorm:"column:user_id"`
        Amount    float64 `gorm:"column:amount"`
}

func (AccountBalance) TableName() string <span class="cov0" title="0">{
        return "account_balances"
}</span>

type AccountDetail struct {
        AccountID     string  `gorm:"column:account_id;primaryKey"`
        UserID        string  `gorm:"column:user_id"`
        Color         string  `gorm:"column:color"`
        IsMainAccount bool    `gorm:"column:is_main_account"`
        Progress      float64 `gorm:"column:progress"`
}

func (AccountDetail) TableName() string <span class="cov0" title="0">{
        return "account_details"
}</span>

type AccountFlag struct {
        FlagID    int       `gorm:"column:flag_id;primaryKey;autoIncrement"`
        AccountID string    `gorm:"column:account_id"`
        UserID    string    `gorm:"column:user_id"`
        FlagType  string    `gorm:"column:flag_type"`
        FlagValue string    `gorm:"column:flag_value"`
        CreatedAt time.Time `gorm:"column:created_at"`
        UpdatedAt time.Time `gorm:"column:updated_at"`

        User *User `gorm:"foreignKey:UserID;references:UserID" json:"user,omitempty"`
}

func (AccountFlag) TableName() string <span class="cov0" title="0">{
        return "account_flags"
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

type Banner struct {
        BannerID    string `gorm:"column:banner_id;primaryKey"`
        UserID      string `gorm:"column:user_id"`
        Title       string `gorm:"column:title"`
        Description string `gorm:"column:description"`
        Image       string `gorm:"column:image"`

        User *User `gorm:"foreignKey:UserID;references:UserID" json:"user,omitempty"`
}

func (Banner) TableName() string <span class="cov0" title="0">{
        return "banners"
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

type DebitCard struct {
        CardID   string `json:"card_id" gorm:"column:card_id;primaryKey"`
        UserID   string `json:"user_id" gorm:"column:user_id"`
        Name     string `json:"name" gorm:"column:name"`

        DebitCardDetail DebitCardDetail `gorm:"foreignKey:CardID"`
        DebitCardDesign DebitCardDesign `gorm:"foreignKey:CardID"`
        DebitCardStatus DebitCardStatus `gorm:"foreignKey:CardID"`
}

func (DebitCard) TableName() string <span class="cov0" title="0">{
        return "debit_cards"
}</span>

type DebitCardStatus struct {
        CardID   string `gorm:"column:card_id;primaryKey"`
        UserID   string `gorm:"column:user_id"`
        Status   string `gorm:"column:status"`
}

func (DebitCardStatus) TableName() string <span class="cov0" title="0">{
        return "debit_card_status"
}</span>

type DebitCardDesign struct {
        CardID      string `gorm:"column:card_id;primaryKey"`
        UserID      string `gorm:"column:user_id"`
        Color       string `gorm:"column:color"`
        BorderColor string `gorm:"column:border_color"`
}

func (DebitCardDesign) TableName() string <span class="cov0" title="0">{
        return "debit_card_design"
}</span>

type DebitCardDetail struct {
        CardID   string `gorm:"column:card_id;primaryKey"`
        UserID   string `gorm:"column:user_id"`
        Issuer   string `gorm:"column:issuer"`
        Number   string `gorm:"column:number"`
}

func (DebitCardDetail) TableName() string <span class="cov0" title="0">{
        return "debit_card_details"
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

type Transaction struct {
        TransactionID string `gorm:"column:transaction_id;primaryKey"`
        UserID        string `gorm:"column:user_id"`
        Name          string `gorm:"column:name"`
        Image         string `gorm:"column:image"`
        IsBank        bool   `gorm:"column:isBank"`

        User *User `gorm:"foreignKey:UserID;references:UserID" json:"user,omitempty"`
}

func (Transaction) TableName() string <span class="cov0" title="0">{
        return "transactions"
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import "time"

type User struct {
        UserID    string     `gorm:"column:user_id;primaryKey"`
        Name      string     `gorm:"column:name"`
        Password  string     `gorm:"column:password"`
        UpdatedAt *time.Time `gorm:"column:updated_at;autoUpdateTime"`

        // Relationships - Proper GORM associations
        Accounts      []Account       `gorm:"foreignKey:UserID;references:UserID" json:"accounts,omitempty"`
        AccountDetail []AccountDetail `gorm:"foreignKey:UserID;references:UserID" json:"accountDetail,omitempty"`
        AccountFlag   []AccountFlag   `gorm:"foreignKey:UserID;references:UserID" json:"accountFlag,omitempty"`
        DebitCards    []DebitCard     `gorm:"foreignKey:UserID;references:UserID" json:"debitCards,omitempty"`
        Transactions  []Transaction   `gorm:"foreignKey:UserID;references:UserID" json:"transactions,omitempty"`
        Banners       []Banner        `gorm:"foreignKey:UserID;references:UserID" json:"banners,omitempty"`

        UserPin      *UserPin      `gorm:"foreignKey:UserID;references:UserID" json:"userPin,omitempty"`
        UserGreeting *UserGreeting `gorm:"foreignKey:UserID;references:UserID" json:"userGreeting,omitempty"`
}

func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>

type UserGreeting struct {
        UserID   string `gorm:"column:user_id;primaryKey"`
        Greeting string `gorm:"column:greeting"`
}

func (UserGreeting) TableName() string <span class="cov0" title="0">{
        return "user_greetings"
}</span>

type UserPin struct {
        UserID            string     `gorm:"column:user_id;primaryKey;not null;index"`
        HashedPin         string     `gorm:"column:hashed_pin"`
        FailedPinAttempts int        `gorm:"column:failed_pin_attempts"`
        LastPinAttemptAt  *time.Time `gorm:"column:last_pin_attempt_at"`
        PinLockedUntil    *time.Time `gorm:"column:pin_locked_until"`

        // Relationship back to User
        User *User `gorm:"foreignKey:UserID;references:UserID" json:"user,omitempty"`
}

func (UserPin) TableName() string <span class="cov0" title="0">{
        return "user_pins"
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package validators

import (
        "fmt"
        "strings"

        "github.com/Testzyler/banking-api/server/exception"
        "github.com/go-playground/validator/v10"
)

// Global validator instance
var validate *validator.Validate

func init() <span class="cov8" title="1">{
        validate = validator.New()
}</span>

func ValidateStruct(s interface{}) error <span class="cov8" title="1">{
        err := validate.Struct(s)
        if err != nil </span><span class="cov8" title="1">{
                var validationErrors []string
                for _, err := range err.(validator.ValidationErrors) </span><span class="cov8" title="1">{
                        var message string

                        switch err.Tag() </span>{
                        case "required":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s is required", getFieldName(err.Field()))</span>
                        case "min":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must be at least %s", getFieldName(err.Field()), err.Param())</span>
                        case "max":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must not exceed %s", getFieldName(err.Field()), err.Param())</span>
                        case "email":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must be a valid email address", getFieldName(err.Field()))</span>
                        case "uuid":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must be a valid UUID", getFieldName(err.Field()))</span>
                        case "len":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must be exactly %s characters", getFieldName(err.Field()), err.Param())</span>
                        case "numeric":<span class="cov0" title="0">
                                message = fmt.Sprintf("%s must be a number", getFieldName(err.Field()))</span>
                        // Custom validation error messages
                        case "account_number":<span class="cov8" title="1">
                                message = fmt.Sprintf("%s must be exactly 12 digits", getFieldName(err.Field()))</span>
                        default:<span class="cov0" title="0">
                                message = fmt.Sprintf("%s is invalid", getFieldName(err.Field()))</span>
                        }

                        <span class="cov8" title="1">validationErrors = append(validationErrors, message)</span>
                }

                <span class="cov8" title="1">return exception.NewValidationError(map[string]interface{}{
                        "errors":  validationErrors,
                        "message": "Validation failed for the provided data",
                })</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Convert camelCase to readable format
func getFieldName(field string) string <span class="cov8" title="1">{
        var result strings.Builder
        for i, r := range field </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; r &gt;= 'A' &amp;&amp; r &lt;= 'Z' </span><span class="cov8" title="1">{
                        result.WriteString(" ")
                }</span>
                <span class="cov8" title="1">result.WriteRune(r)</span>
        }

        <span class="cov8" title="1">return strings.ToLower(result.String())</span>
}

// Custom validation functions
func RegisterCustomValidations() <span class="cov8" title="1">{
        // Custom validation for account numbers (7-12 digits)
        validate.RegisterValidation("account_number", func(fl validator.FieldLevel) bool </span><span class="cov8" title="1">{
                accountNo := fl.Field().String()
                if len(accountNo) != 12 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">for _, char := range accountNo </span><span class="cov8" title="1">{
                        if char &lt; '0' || char &gt; '9' </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        })
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cmd

import (
        "log"

        "github.com/spf13/cobra"
)

var cmd = &amp;cobra.Command{
        Use:   "banking-api",
        Short: "Start the Banking API server",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cmd.Usage()
        }</span>,
}

// Execute root command
func Execute() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error executing root command: %v", err)
        }</span>
}

var configFile string

func init() <span class="cov0" title="0">{
        cmd.PersistentFlags().StringVar(&amp;configFile, "config", "config.yaml", "Config file (default is config.yaml)")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package cmd

import (
        "fmt"

        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/database"
        "github.com/spf13/cobra"
)

// MigrateCmd is the command to run database migrations
var migrateCmd = &amp;cobra.Command{
        Use:   "migrate",
        Short: "Run database migrations",
        Long:  "This command runs the database migrations to ensure the database schema is up to date.",
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                // Load configuration
                config := config.NewConfig(configFile)

                // Initialize database connection
                db, err := database.NewDatabase(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get database connection: %w", err)
                }</span>
                <span class="cov0" title="0">defer db.Close()

                // Run migrations
                fmt.Println("Starting database migrations...")
                if err := db.RunMigrations(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration failed: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Database migrations completed successfully.")
                return nil</span>
        },
}

func init() <span class="cov0" title="0">{
        cmd.AddCommand(migrateCmd)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package cmd

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/Testzyler/banking-api/app/validators"
        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/logger"
        "github.com/Testzyler/banking-api/server"
        "github.com/spf13/cobra"
)

var wg sync.WaitGroup
var httpServer *server.Server

var serveCmd = &amp;cobra.Command{
        Use:   "serve_api",
        Short: "Serve the API",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Create root context with cancellation
                ctx, cancel := context.WithCancel(context.Background())
                defer cancel()

                // Load configuration
                config := config.NewConfig(configFile)

                // Initialize logger
                loggerConfig := &amp;logger.LoggerConfig{
                        Level:       config.Logger.Level,
                        Environment: config.Server.Environment,
                        LogColor:    config.Logger.LogColor,
                        LogJson:     config.Logger.LogJson,
                }
                if err := logger.InitLogger(loggerConfig); err != nil </span><span class="cov0" title="0">{
                        panic("Failed to initialize logger: " + err.Error())</span>
                }
                <span class="cov0" title="0">defer logger.SyncLogger()

                // Initialize custom validations
                validators.RegisterCustomValidations()

                // Start the HTTP server
                logger.Info("Starting Banking API Server", "port", config.Server.Port, "environment", config.Server.Environment)
                initHttpServer(ctx, config)

                // Setup signal handling for graceful shutdown
                quit := make(chan os.Signal, 1)
                signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
                select </span>{
                case sig := &lt;-quit:<span class="cov0" title="0">
                        logger.Info("Received shutdown signal", "signal", sig.String())</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Info("Application context cancelled")</span>
                }

                // Create shutdown context with timeout
                <span class="cov0" title="0">shutdownTimeout := time.Duration(config.Server.ShutdownTimeout) * time.Second
                if shutdownTimeout == 0 </span><span class="cov0" title="0">{
                        shutdownTimeout = 30 * time.Second // Default 30 seconds
                }</span>
                <span class="cov0" title="0">shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), shutdownTimeout)
                defer shutdownCancel()

                shutdownComplete := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        defer close(shutdownComplete)
                        cancel()
                        if httpServer != nil </span><span class="cov0" title="0">{
                                if err := httpServer.Shutdown(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Error during HTTP server shutdown", "error", err)
                                }</span>
                        }

                        <span class="cov0" title="0">wg.Wait()</span>
                }()

                <span class="cov0" title="0">logger.Info("Initiating graceful shutdown...")
                select </span>{
                case &lt;-shutdownComplete:<span class="cov0" title="0">
                        logger.Info("Graceful shutdown completed successfully")</span>
                case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                        logger.Error("Shutdown timeout exceeded, forcing exit", "timeout", shutdownTimeout)
                        // Force exit if graceful shutdown takes too long
                        os.Exit(1)</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        cmd.AddCommand(serveCmd)
}</span>

func initHttpServer(ctx context.Context, config *config.Config) <span class="cov0" title="0">{
        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                // Initialize server
                httpServer = server.NewServer(ctx, config)
                logger.Infof("HTTP server started on port %s", config.Server.Port)
                err := httpServer.Start()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("Error starting HTTP server %d : %v", config.Server.Port, err)
                        return
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "log"
        "strings"
        "sync"
        "time"

        "github.com/spf13/viper"
)

type Config struct {
        Server   *Server
        Database *Database
        Cache    *CacheConfig
        Logger   *Logger
        Auth     *AuthConfig
}

type Server struct {
        Port            string
        ReadTimeout     time.Duration
        WriteTimeout    time.Duration
        IdleTimeout     time.Duration
        Environment     string
        MaxConnections  int
        ShutdownTimeout int
}

type Database struct {
        Host                string
        Port                string
        Username            string
        Password            string
        Name                string
        MaxOpenConns        int
        MaxIdleTimeInSecond int
}

type CacheConfig struct {
        // Single instance configuration
        Host     string
        Port     int
        Password string
        DB       int

        // Connection pool settings
        MaxIdle     int
        IdleTimeout time.Duration

        // Sentinel configuration
        UseSentinel      bool
        SentinelAddrs    []string
        SentinelPassword string
        MasterName       string
}

type Logger struct {
        Level    string
        LogColor bool
        LogJson  bool
}

type AuthConfig struct {
        Jwt *JwtConfig
        Pin *PinConfig
}

type JwtConfig struct {
        AccessTokenSecret  string
        RefreshTokenSecret string
        AccessTokenExpiry  time.Duration
        RefreshTokenExpiry time.Duration
}

type PinConfig struct {
        BaseDuration    time.Duration
        LockThreshold   int
        MaxLockDuration time.Duration
}

var (
        once   sync.Once
        config *Config
)

func NewConfig(envFile string) *Config <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                config = loadConfig(envFile)
        }</span>)
        <span class="cov0" title="0">return config</span>
}

var envFile string

func loadConfig(envFile string) *Config <span class="cov0" title="0">{
        if envFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(envFile)
        }</span> else<span class="cov0" title="0"> {
                viper.AddConfigPath(".")
                viper.AddConfigPath("..")
                viper.SetConfigName("config")
                viper.SetConfigType("yaml")
        }</span>

        <span class="cov0" title="0">replacer := strings.NewReplacer(".", "_")
        viper.SetEnvKeyReplacer(replacer)

        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to read config: %v\n", err)
        }</span>
        <span class="cov0" title="0">return &amp;Config{
                Server: &amp;Server{
                        Port:            viper.GetString("Server.Port"),
                        ReadTimeout:     viper.GetDuration("Server.ReadTimeout"),
                        WriteTimeout:    viper.GetDuration("Server.WriteTimeout"),
                        IdleTimeout:     viper.GetDuration("Server.IdleTimeout"),
                        MaxConnections:  viper.GetInt("Server.MaxConnections"),
                        ShutdownTimeout: viper.GetInt("Server.ShutdownTimeout"),
                        Environment:     viper.GetString("Server.Environment"),
                },
                Database: &amp;Database{
                        Host:                viper.GetString("Database.Host"),
                        Port:                viper.GetString("Database.Port"),
                        Username:            viper.GetString("Database.Username"),
                        Password:            viper.GetString("Database.Password"),
                        Name:                viper.GetString("Database.Name"),
                        MaxOpenConns:        viper.GetInt("Database.MaxOpenConns"),
                        MaxIdleTimeInSecond: viper.GetInt("Database.MaxIdleTimeInSecond"),
                },
                Cache: &amp;CacheConfig{
                        Host:             viper.GetString("Redis.Host"),
                        Port:             viper.GetInt("Redis.Port"),
                        Password:         viper.GetString("Redis.Password"),
                        DB:               viper.GetInt("Redis.DB"),
                        MaxIdle:          viper.GetInt("Redis.MaxIdle"),
                        IdleTimeout:      viper.GetDuration("Redis.IdleTimeout"),
                        UseSentinel:      viper.GetBool("Redis.UseSentinel"),
                        SentinelAddrs:    viper.GetStringSlice("Redis.SentinelAddrs"),
                        SentinelPassword: viper.GetString("Redis.SentinelPassword"),
                        MasterName:       viper.GetString("Redis.MasterName"),
                },
                Logger: &amp;Logger{
                        Level:    viper.GetString("Logger.Level"),
                        LogColor: viper.GetBool("Logger.LogColor"),
                        LogJson:  viper.GetBool("Logger.LogJson"),
                },
                Auth: &amp;AuthConfig{
                        Jwt: &amp;JwtConfig{
                                AccessTokenSecret:  viper.GetString("Auth.Jwt.AccessTokenSecret"),
                                RefreshTokenSecret: viper.GetString("Auth.Jwt.RefreshTokenSecret"),
                                AccessTokenExpiry:  time.Duration(viper.GetInt("Auth.Jwt.AccessTokenExpiry")) * time.Minute,
                                RefreshTokenExpiry: time.Duration(viper.GetInt("Auth.Jwt.RefreshTokenExpiry")) * 24 * time.Hour,
                        },
                        Pin: &amp;PinConfig{
                                BaseDuration:    viper.GetDuration("Auth.Pin.BaseDuration"),
                                LockThreshold:   viper.GetInt("Auth.Pin.LockThreshold"),
                                MaxLockDuration: viper.GetDuration("Auth.Pin.MaxLockDuration"),
                        },
                },
        }</span>
}

func GetConfig() *Config <span class="cov0" title="0">{
        return config
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package database

import (
        "sync"

        "github.com/Testzyler/banking-api/config"
        "gorm.io/gorm"
)

type DatabaseInterface interface {
        GetDB() *gorm.DB
        RunMigrations() error
        Close() error
}

type Database struct {
        DB *gorm.DB
}

// Global variables  Database  Cache instances
var (
        dbOnce        sync.Once
        cacheOnce     sync.Once
        dbInstance    DatabaseInterface
        cacheInstance *RedisDatabase
)

// GetDatabase returns global database instance (singleton)
func GetDatabase() DatabaseInterface <span class="cov0" title="0">{
        if dbInstance == nil </span><span class="cov0" title="0">{
                dbOnce.Do(func() </span><span class="cov0" title="0">{
                        var err error
                        dbInstance, err = NewMySQLDatabase(config.GetConfig())
                        if err != nil </span><span class="cov0" title="0">{
                                panic("Failed to connect to database: " + err.Error())</span>
                        }
                })
        }
        <span class="cov0" title="0">return dbInstance</span>
}

// GetCache returns global cache instance (singleton)
func GetCache() *RedisDatabase <span class="cov0" title="0">{
        if cacheInstance == nil </span><span class="cov0" title="0">{
                cacheOnce.Do(func() </span><span class="cov0" title="0">{
                        var err error
                        cacheInstance, err = NewCacheClient(config.GetConfig().Cache)
                        if err != nil </span><span class="cov0" title="0">{
                                panic("Failed to connect to cache: " + err.Error())</span>
                        }
                })
        }
        <span class="cov0" title="0">return cacheInstance</span>
}

// InitDatabase initializes global database instance
func InitDatabase(cfg *config.Config) error <span class="cov0" title="0">{
        dbOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                dbInstance, err = NewMySQLDatabase(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        panic("Failed to connect to database: " + err.Error())</span>
                }
        })
        <span class="cov0" title="0">return nil</span>
}

// InitCache initializes global cache instance
func InitCache(cfg *config.CacheConfig) error <span class="cov0" title="0">{
        cacheOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                cacheInstance, err = NewCacheClient(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        panic("Failed to connect to cache: " + err.Error())</span>
                }
        })
        <span class="cov0" title="0">return nil</span>
}

func NewDatabase(config *config.Config) (DatabaseInterface, error) <span class="cov0" title="0">{
        return NewMySQLDatabase(config)
}</span>

func NewCache(config *config.CacheConfig) (*RedisDatabase, error) <span class="cov0" title="0">{
        return NewCacheClient(config)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package migrations

import (
        "fmt"
        "os"
        "strings"

        "gorm.io/gorm"
)

var path = ""

var initialSchemaSetup = &amp;Migration{
        Number: 1,
        Name:   "add seed mock data",

        Forwards: func(db *gorm.DB) error <span class="cov0" title="0">{
                tx := db.Begin()
                if tx.Error != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not start transaction: %w", tx.Error)
                }</span>

                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                        }</span>
                }()

                <span class="cov0" title="0">mockDir := "database/seeds"
                files, err := os.ReadDir(mockDir)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not read mock directory: %w", err)
                }</span>

                <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                        if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".sql") </span><span class="cov0" title="0">{
                                fmt.Printf("Executing SQL file: %s\n", file.Name())
                                filePath := fmt.Sprintf("%s/%s", mockDir, file.Name())
                                err := executeSQLFile(tx, filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        tx.Rollback()
                                        return fmt.Errorf("could not execute SQL file %s: %w", file.Name(), err)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return tx.Commit().Error</span>
        },
}

func executeSQLFile(db *gorm.DB, filePath string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not read SQL file %s: %w", filePath, err)
        }</span>

        <span class="cov0" title="0">sql := string(content)
        if strings.TrimSpace(sql) == "" </span><span class="cov0" title="0">{
                return nil // skip empty files
        }</span>

        // multiple statements
        <span class="cov0" title="0">statements := strings.Split(sql, ";")

        for i, statement := range statements </span><span class="cov0" title="0">{
                statement = strings.TrimSpace(statement)
                if statement == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">err = db.Exec(statement).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not execute statement %d from file %s: %w", i+1, filePath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov0" title="0">{
        Migrations = append(Migrations, initialSchemaSetup)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package migrations

import (
        "fmt"

        "github.com/Testzyler/banking-api/app/models"
        "github.com/Testzyler/banking-api/logger"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

var createUserPin = &amp;Migration{
        Number: 2,
        Name:   "create user pin",

        Forwards: func(db *gorm.DB) error <span class="cov0" title="0">{
                return Migrate_CreateUserPin(db)
        }</span>,
}

func Migrate_CreateUserPin(db *gorm.DB) error <span class="cov0" title="0">{
        if err := db.Migrator().CreateTable(&amp;models.UserPin{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Info("Created UserPin table.")

        const defaultPIN = "123456"
        hashedDefaultPIN, err := bcrypt.GenerateFromPassword([]byte(defaultPIN), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var existingUsers []models.User
        if err := db.Table("users").Select("user_id").Find(&amp;existingUsers).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("Error query existing users: %v\n", err)
                return fmt.Errorf("failed to query existing users: %w", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Found %d existing users to migrate.\n", len(existingUsers))

        if len(existingUsers) == 0 </span><span class="cov0" title="0">{
                logger.Error("No existing users found. Skipping PIN population.")
                return nil
        }</span>
        <span class="cov0" title="0">var userPinsToCreate []models.UserPin
        for _, user := range existingUsers </span><span class="cov0" title="0">{
                userPinsToCreate = append(userPinsToCreate, models.UserPin{
                        UserID:            user.UserID,
                        HashedPin:         string(hashedDefaultPIN),
                        FailedPinAttempts: 0,
                })
        }</span>

        <span class="cov0" title="0">if err := db.CreateInBatches(userPinsToCreate, 1000).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("Error UserPin records in batches: %v\n", err)
                return fmt.Errorf("failed to insert user PINs: %w", err)
        }</span>
        <span class="cov0" title="0">logger.Info("Created %d user pins.\n", len(userPinsToCreate))

        return nil</span>
}

func init() <span class="cov0" title="0">{
        Migrations = append(Migrations, createUserPin)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package migrations

import (
        "github.com/Testzyler/banking-api/logger"
        "gorm.io/gorm"
)

var createIndex = &amp;Migration{
        Number: 3,
        Name:   "create index table",

        Forwards: func(db *gorm.DB) error <span class="cov0" title="0">{
                return Migrate_CreateIndex(db)
        }</span>,
}

func init() <span class="cov0" title="0">{
        Migrations = append(Migrations, createIndex)
}</span>

func Migrate_CreateIndex(db *gorm.DB) error <span class="cov0" title="0">{

        statements := []string{
                // users
                `CREATE INDEX idx_users_user_id ON users(user_id);`,
                `CREATE INDEX idx_users_name ON users(name);`,

                // accounts
                `CREATE INDEX idx_accounts_user_id ON accounts(user_id);`,

                // account_balances
                `CREATE INDEX idx_account_balances_user_id ON account_balances(user_id);`,
                `CREATE INDEX idx_account_balances_account_id ON account_balances(account_id);`,

                // account_details
                `CREATE INDEX idx_account_details_user_id ON account_details(user_id);`,
                `CREATE INDEX idx_account_details_account_id ON account_details(account_id);`,

                // account_flags
                `CREATE INDEX idx_account_flags_account_id ON account_flags(account_id);`,
                `CREATE INDEX idx_account_flags_user_id ON account_flags(user_id);`,

                // debit_cards
                `CREATE INDEX idx_debit_cards_user_id ON debit_cards(user_id);`,

                // debit_card_details
                `CREATE INDEX idx_debit_card_details_user_id ON debit_card_details(user_id);`,
                `CREATE INDEX idx_debit_card_details_card_id ON debit_card_details(card_id);`,

                // debit_card_design
                `CREATE INDEX idx_debit_card_design_card_id ON debit_card_design(card_id);`,
                `CREATE INDEX idx_debit_card_design_user_id ON debit_card_design(user_id);`,

                // debit_card_status
                `CREATE INDEX idx_debit_card_status_card_id ON debit_card_status(card_id);`,
                `CREATE INDEX idx_debit_card_status_user_id ON debit_card_status(user_id);`,

                // user_greetings
                `CREATE INDEX idx_user_greetings_user_id ON user_greetings(user_id);`,

                // banners
                `CREATE INDEX idx_banners_user_id ON banners(user_id);`,

                // transactions
                `CREATE INDEX idx_transactions_user_id ON transactions(user_id);`,
        }

        for _, stmt := range statements </span><span class="cov0" title="0">{
                if err := db.Exec(stmt).Error; err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to execute statement: %s, error: %w", stmt, err)
                }</span>
        }

        <span class="cov0" title="0">logger.Infof("Index created successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package migrations

import (
        "github.com/Testzyler/banking-api/logger"
        "gorm.io/gorm"
)

var deleteUnUsedColumns = &amp;Migration{
        Number: 4,
        Name:   "delete un used columns",

        Forwards: func(db *gorm.DB) error <span class="cov0" title="0">{
                return Migrate_DeleteUnUsedColumns(db)
        }</span>,
}

func init() <span class="cov0" title="0">{
        Migrations = append(Migrations, deleteUnUsedColumns)
}</span>

func Migrate_DeleteUnUsedColumns(db *gorm.DB) error <span class="cov0" title="0">{

        statements := []string{
                // account_balances
                `ALTER TABLE users DROP COLUMN dummy_col_1;`,
                `ALTER TABLE user_greetings DROP COLUMN dummy_col_2;`,
                `ALTER TABLE accounts DROP COLUMN dummy_col_3;`,
                `ALTER TABLE account_balances DROP COLUMN dummy_col_4;`,
                `ALTER TABLE account_details DROP COLUMN dummy_col_5;`,
                `ALTER TABLE transactions DROP COLUMN dummy_col_6;`,
                `ALTER TABLE debit_cards DROP COLUMN dummy_col_7;`,
                `ALTER TABLE debit_card_status DROP COLUMN dummy_col_8;`,
                `ALTER TABLE debit_card_design DROP COLUMN dummy_col_9;`,
                `ALTER TABLE debit_card_details DROP COLUMN dummy_col_10;`,
                `ALTER TABLE banners DROP COLUMN dummy_col_11;`,
        }

        for _, stmt := range statements </span><span class="cov0" title="0">{
                if err := db.Exec(stmt).Error; err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to execute statement: %s, error: %w", stmt, err)
                }</span>
                <span class="cov0" title="0">logger.Infof("executed statement: %s", stmt)</span>
        }

        <span class="cov0" title="0">logger.Infof("Index and FK created successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package database

import (
        "fmt"
        "time"

        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/database/migrations"
        "github.com/Testzyler/banking-api/logger"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        gormLogger "gorm.io/gorm/logger"
)

func NewMySQLDatabase(config *config.Config) (DatabaseInterface, error) <span class="cov8" title="1">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                config.Database.Username,
                config.Database.Password,
                config.Database.Host,
                config.Database.Port,
                config.Database.Name,
        )

        db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
                Logger: gormLogger.Default.LogMode(gormLogger.Warn),
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Get underlying sql.DB to configure connection pool
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(int(config.Database.MaxOpenConns))
        sqlDB.SetMaxIdleConns(int(config.Database.MaxOpenConns) / 2)
        sqlDB.SetConnMaxIdleTime(time.Duration(config.Database.MaxIdleTimeInSecond) * time.Second)

        database := &amp;Database{DB: db}

        return database, nil</span>
}

func (d *Database) GetDB() *gorm.DB <span class="cov0" title="0">{
        return d.DB
}</span>

func (d *Database) RunMigrations() error <span class="cov0" title="0">{
        // First, create migrations table if it doesn't exist
        if err := d.DB.AutoMigrate(&amp;migrations.Migration{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Run each migration that hasn't been run yet
        <span class="cov0" title="0">for _, migration := range migrations.Migrations </span><span class="cov0" title="0">{
                var existingMigration migrations.Migration
                result := d.DB.Where("number = ?", migration.Number).First(&amp;existingMigration)

                if result.Error != nil &amp;&amp; result.Error != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check migration %d: %w", migration.Number, result.Error)
                }</span>

                // If migration doesn't exist, run it
                <span class="cov0" title="0">if result.Error == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        logger.Infof("Running migration %d: %s",
                                migration.Number,
                                migration.Name,
                        )

                        if err := migration.Forwards(d.DB); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("migration %d failed: %w", migration.Number, err)
                        }</span>

                        // Record that migration was run
                        <span class="cov0" title="0">migrationRecord := &amp;migrations.Migration{
                                Number: migration.Number,
                                Name:   migration.Name,
                        }
                        if err := d.DB.Create(migrationRecord).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to record migration %d: %w", migration.Number, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *Database) Close() error <span class="cov0" title="0">{
        sqlDB, err := d.DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqlDB.Close()</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package database

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/logger"
        "github.com/redis/go-redis/v9"
)

// RedisDatabase is a struct that holds the Redis client
type RedisDatabase struct {
        Client redis.Cmdable
        config *config.CacheConfig
}

func (r *RedisDatabase) GetClient() redis.Cmdable <span class="cov0" title="0">{
        return r.Client
}</span>

func (r *RedisDatabase) GetConfig() *config.CacheConfig <span class="cov0" title="0">{
        return r.config
}</span>

func NewCacheClient(config *config.CacheConfig) (*RedisDatabase, error) <span class="cov8" title="1">{
        var client redis.Cmdable

        if config.UseSentinel </span><span class="cov8" title="1">{
                // Redis Sentinel configuration
                logger.Infof("Initializing Redis client with Sentinel configuration")
                logger.Infof("Sentinel addresses: %v", config.SentinelAddrs)
                logger.Infof("Master name: %s", config.MasterName)

                client = redis.NewFailoverClient(&amp;redis.FailoverOptions{
                        MasterName:       config.MasterName,
                        SentinelAddrs:    config.SentinelAddrs,
                        SentinelPassword: config.SentinelPassword,
                        Password:         config.Password,
                        DB:               config.DB,
                        MaxRetries:       3,
                        DialTimeout:      5 * time.Second,
                        ReadTimeout:      3 * time.Second,
                        WriteTimeout:     3 * time.Second,
                        PoolSize:         10,
                        MinIdleConns:     config.MaxIdle,
                        ConnMaxIdleTime:  config.IdleTimeout,
                })
        }</span> else<span class="cov8" title="1"> {
                // Single Redis instance configuration
                logger.Infof("Initializing Redis client with single instance configuration")
                logger.Infof("Redis address: %s:%d", config.Host, config.Port)

                client = redis.NewClient(&amp;redis.Options{
                        Addr:            config.Host + ":" + strconv.Itoa(config.Port),
                        Password:        config.Password,
                        DB:              config.DB,
                        MaxRetries:      3,
                        DialTimeout:     5 * time.Second,
                        ReadTimeout:     3 * time.Second,
                        WriteTimeout:    3 * time.Second,
                        PoolSize:        10,
                        MinIdleConns:    config.MaxIdle,
                        ConnMaxIdleTime: config.IdleTimeout,
                })
        }</span>

        // Test the connection
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to Redis: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully connected to Redis")

        return &amp;RedisDatabase{
                Client: client,
                config: config,
        }, nil</span>
}

// Close closes the Redis connection
func (r *RedisDatabase) Close() error <span class="cov0" title="0">{
        if clientWithClose, ok := r.Client.(interface{ Close() error }); ok </span><span class="cov0" title="0">{
                return clientWithClose.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package logger

import (
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

var (
        Logger *zap.SugaredLogger
)

type LoggerConfig struct {
        Level       string `mapstructure:"level"`       // debug, info, warn, error
        Environment string `mapstructure:"environment"` // development, production
        LogColor    bool   `mapstructure:"log_color"`   // true or false
        LogJson     bool   `mapstructure:"log_json"`    // true or false
}

func getLogLevel(level string) zapcore.Level <span class="cov0" title="0">{
        switch level </span>{
        case "info":<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        case "warn":<span class="cov0" title="0">
                return zapcore.WarnLevel</span>
        case "debug":<span class="cov0" title="0">
                return zapcore.DebugLevel</span>
        case "error":<span class="cov0" title="0">
                return zapcore.ErrorLevel</span>
        case "fatal":<span class="cov0" title="0">
                return zapcore.FatalLevel</span>
        default:<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        }
}

func InitLogger(config *LoggerConfig) error <span class="cov0" title="0">{
        var logEncoderConfig zapcore.EncoderConfig
        var logEncoder zapcore.Encoder

        logLevel := getLogLevel(config.Level)

        // Set encoder config based on environment
        if config.Environment == "production" </span><span class="cov0" title="0">{
                logEncoderConfig = zap.NewProductionEncoderConfig()
                logEncoderConfig.EncodeLevel = zapcore.LowercaseLevelEncoder
                logEncoder = zapcore.NewJSONEncoder(logEncoderConfig)
        }</span> else<span class="cov0" title="0"> {
                logEncoderConfig = zap.NewDevelopmentEncoderConfig()
                logEncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder

                if config.LogColor </span><span class="cov0" title="0">{
                        logEncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
                }</span> else<span class="cov0" title="0"> {
                        logEncoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
                }</span>

                <span class="cov0" title="0">if config.LogJson </span><span class="cov0" title="0">{
                        logEncoder = zapcore.NewJSONEncoder(logEncoderConfig)
                }</span> else<span class="cov0" title="0"> {
                        logEncoder = zapcore.NewConsoleEncoder(logEncoderConfig)
                }</span>
        }

        <span class="cov0" title="0">core := zapcore.NewCore(
                logEncoder,
                os.Stdout,
                zap.NewAtomicLevelAt(logLevel),
        )

        zapLogger := zap.New(core, zap.AddCaller(), zap.AddStacktrace(zap.ErrorLevel))
        Logger = zapLogger.Sugar()
        return nil</span>
}

func SyncLogger() <span class="cov0" title="0">{
        Logger.Infof("Flush logger")
        Logger.Sync()
}</span>

// Convenience methods to use the global logger instance
func Info(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Infow(msg, keysAndValues...)
        }</span>
}

func Infof(template string, args ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Infof(template, args...)
        }</span>
}

func Debug(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Debugw(msg, keysAndValues...)
        }</span>
}

func Debugf(template string, args ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Debugf(template, args...)
        }</span>
}

func Warn(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Warnw(msg, keysAndValues...)
        }</span>
}

func Warnf(template string, args ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Warnf(template, args...)
        }</span>
}

func Error(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Errorw(msg, keysAndValues...)
        }</span>
}

func Errorf(template string, args ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Errorf(template, args...)
        }</span>
}

func Fatal(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Fatalw(msg, keysAndValues...)
        }</span> else<span class="cov0" title="0"> {
                // Fallback if logger is not initialized
                os.Exit(1)
        }</span>
}

func Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                Logger.Fatalf(template, args...)
        }</span> else<span class="cov0" title="0"> {
                os.Exit(1)
        }</span>
}

func With(args ...interface{}) *zap.SugaredLogger <span class="cov0" title="0">{
        if Logger != nil </span><span class="cov0" title="0">{
                return Logger.With(args...)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetLogger() *zap.SugaredLogger <span class="cov0" title="0">{
        return Logger
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package main

import (
        "runtime"

        "github.com/Testzyler/banking-api/cmd"
)

func main() <span class="cov0" title="0">{
        runtime.GOMAXPROCS(runtime.NumCPU())
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package exception

import (
        "fmt"

        "github.com/Testzyler/banking-api/server/response"
        "github.com/gofiber/fiber/v2"
)

// Predefined error responses that implement the error interface (error_handler)
var (
        // PIN errors
        ErrPinLocked = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "PIN locked",
                Details:        "The PIN is locked. Please try again in",
        }

        ErrPinExpired = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "PIN expired",
                Details:        "The PIN has expired. Please try again",
        }

        ErrInvalidPin = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Invalid PIN",
                Details:        "The PIN is incorrect. Please try again",
        }

        // 4xx Client Errors
        ErrUserNotFound = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusNotFound,
                Code:           response.ErrCodeNotFound,
                Message:        "User not found",
                Details:        "The user with the specified ID does not exist",
        }

        ErrInvalidUserID = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusBadRequest,
                Code:           response.ErrCodeBadRequest,
                Message:        "Invalid user ID",
                Details:        "The provided user ID is not valid or empty",
        }

        ErrInvalidPagination = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusBadRequest,
                Code:           response.ErrCodeBadRequest,
                Message:        "Invalid pagination parameters",
                Details:        "Page number must be positive and perPage must be between 1 and 100",
        }

        ErrValidationFailed = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnprocessableEntity,
                Code:           response.ErrCodeValidationFailed,
                Message:        "Validation failed",
                Details:        "The provided data did not pass validation checks",
        }

        ErrUnauthorized = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Unauthorized",
                Details:        "Authentication credentials are missing or invalid",
        }

        ErrTokenExpired = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Token expired",
                Details:        "The token has expired",
        }

        ErrForbidden = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusForbidden,
                Code:           response.ErrCodeForbidden,
                Message:        "Forbidden",
                Details:        "You do not have permission to access this resource",
        }

        // 5xx Server Errors
        ErrInternalServer = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusInternalServerError,
                Code:           response.ErrCodeInternalServer,
                Message:        "Internal server error",
                Details:        "An unexpected error occurred while processing your request",
        }

        ErrDatabaseConnection = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusInternalServerError,
                Code:           response.ErrCodeDatabaseError,
                Message:        "Database connection error",
                Details:        "Unable to connect to the database",
        }

        ErrServiceUnavailable = &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusServiceUnavailable,
                Code:           response.ErrCodeServiceUnavailable,
                Message:        "Service unavailable",
                Details:        "The service is temporarily unavailable",
        }
)

// Helper functions to create custom errors with dynamic details
func NewUserNotFoundError(userID string) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusNotFound,
                Code:           response.ErrCodeNotFound,
                Message:        "User not found",
                Details:        "User with ID '" + userID + "' does not exist",
        }
}</span>

func NewValidationError(details interface{}) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnprocessableEntity,
                Code:           response.ErrCodeValidationFailed,
                Message:        "Validation failed",
                Details:        details,
        }
}</span>

func NewInternalError(err error) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusInternalServerError,
                Code:           response.ErrCodeInternalServer,
                Message:        "Internal server error",
                Details:        err.Error(),
        }
}</span>

func NewDatabaseError(err error) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusInternalServerError,
                Code:           response.ErrCodeDatabaseError,
                Message:        "Database error",
                Details:        err.Error(),
        }
}</span>

func NewPinLockedError(remainingTime string) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        ErrPinLocked.Message,
                Details:        fmt.Sprintf("%s %s", ErrPinLocked.Details, remainingTime),
        }
}</span>

func NewInvalidPinError(remainingAttempts int) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Invalid PIN",
                Details:        fmt.Sprintf("The PIN is incorrect. %d attempts remaining before lock", remainingAttempts),
        }
}</span>

func NewTokenBannedError() *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Token has been banned",
                Details:        "This token has been revoked and can no longer be used",
        }
}</span>

func NewTokenOutdatedError(reason string) *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusUnauthorized,
                Code:           response.ErrCodeUnauthorized,
                Message:        "Token is outdated",
                Details:        reason,
        }
}</span>

func NewTokenBanFailedError() *response.ErrorResponse <span class="cov0" title="0">{
        return &amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusInternalServerError,
                Code:           response.ErrCodeInternalServer,
                Message:        "Failed to ban tokens",
                Details:        "An error occurred while trying to ban user tokens",
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package middlewares

import (
        "strings"

        authRepository "github.com/Testzyler/banking-api/app/features/auth/repository"
        authService "github.com/Testzyler/banking-api/app/features/auth/service"
        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/database"
        "github.com/Testzyler/banking-api/logger"
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/gofiber/fiber/v2"
)

func AuthMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.Locals("status", fiber.StatusUnauthorized)
                        return exception.ErrUnauthorized
                }</span>

                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.Locals("status", fiber.StatusUnauthorized)
                        return exception.ErrUnauthorized
                }</span>

                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                if token == "" </span><span class="cov0" title="0">{
                        c.Locals("status", fiber.StatusUnauthorized)
                        return exception.ErrUnauthorized
                }</span>

                <span class="cov0" title="0">authRepo := authRepository.NewAuthRepository(database.GetDatabase().GetDB(), database.GetCache())
                jwtService := authService.NewJwtService(config.GetConfig(), authRepo)
                validationResult, err := jwtService.ValidateTokenWithBanCheck(token)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warnf("Token validation failed: %v", err)
                        c.Locals("status", fiber.StatusUnauthorized)
                        return err
                }</span>

                <span class="cov0" title="0">if !validationResult.Valid </span><span class="cov0" title="0">{
                        logger.Infof("Blocked request with invalid token, reason: %s", validationResult.Reason)
                        c.Locals("status", fiber.StatusUnauthorized)
                        return exception.ErrUnauthorized
                }</span>

                <span class="cov0" title="0">c.Locals("user", validationResult.Claims)
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package middlewares

import (
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/Testzyler/banking-api/server/response"
        "github.com/gofiber/fiber/v2"
)

// ErrorHandler
func ErrorHandler() fiber.ErrorHandler <span class="cov0" title="0">{
        return func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                // Check if it's a custom error response type
                if errResp, ok := err.(*response.ErrorResponse); ok </span><span class="cov0" title="0">{
                        return c.Status(errResp.HttpStatusCode).JSON(errResp)
                }</span>

                // Check if it's a fiber error
                <span class="cov0" title="0">if fiberErr, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                        return c.Status(fiberErr.Code).JSON(&amp;response.ErrorResponse{
                                HttpStatusCode: fiber.StatusInternalServerError,
                                Code:           response.ErrCodeBadRequest,
                                Message:        fiberErr.Message,
                                Details:        "Request processing failed",
                        })
                }</span>

                <span class="cov0" title="0">responseError := exception.NewInternalError(err)
                return c.Status(fiber.StatusInternalServerError).JSON(responseError)</span>
        }
}

func NotFoundHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusNotFound).JSON(&amp;response.ErrorResponse{
                HttpStatusCode: fiber.StatusNotFound,
                Code:           response.ErrCodeNotFound,
                Message:        "Resource not found",
                Details:        "The requested resource could not be found on the server.",
        })
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package middlewares

import (
        "time"

        "github.com/Testzyler/banking-api/logger"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

func RequestIDMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                requestID := c.Get("X-Request-ID")

                if requestID == "" </span><span class="cov0" title="0">{
                        uuid, err := uuid.NewV7()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">requestID = uuid.String()</span>
                }

                // use in handlers
                <span class="cov0" title="0">c.Locals("requestID", requestID)

                // for clients
                c.Set("X-Request-ID", requestID)

                return c.Next()</span>
        }
}

func GetRequestID(c *fiber.Ctx) string <span class="cov0" title="0">{
        if requestID, ok := c.Locals("requestID").(string); ok </span><span class="cov0" title="0">{
                return requestID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func GetStatus(c *fiber.Ctx) int <span class="cov0" title="0">{
        if status, ok := c.Locals("status").(int); ok </span><span class="cov0" title="0">{
                return status
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func LoggerMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                requestID := GetRequestID(c)
                requestLogger := logger.With("request_id", requestID)
                c.Locals("logger", requestLogger)

                err := c.Next()
                duration := time.Since(start)
                status := c.Context().Response.StatusCode()
                statusCode := GetStatus(c)

                if status &gt;= 500 || statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        requestLogger.Errorw("HTTP Response",
                                "method", c.Method(),
                                "path", c.Path(),
                                "status", status,
                                "duration", duration,
                        )
                }</span> else<span class="cov0" title="0"> if status &gt;= 400 || statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        requestLogger.Warnw("HTTP Response",
                                "method", c.Method(),
                                "path", c.Path(),
                                "status", status,
                                "duration", duration,
                        )
                }</span> else<span class="cov0" title="0"> {
                        requestLogger.Infow("HTTP Response",
                                "method", c.Method(),
                                "path", c.Path(),
                                "status", status,
                                "duration", duration,
                        )
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

func GetRequestLogger(c *fiber.Ctx) *zap.SugaredLogger <span class="cov0" title="0">{
        if requestLogger, ok := c.Locals("logger").(*zap.SugaredLogger); ok </span><span class="cov0" title="0">{
                return requestLogger
        }</span>

        <span class="cov0" title="0">requestID := GetRequestID(c)
        return logger.With("request_id", requestID)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package response

import (
        "fmt"
)

// SuccessResponse represents a successful API response
type SuccessResponse struct {
        Code    ResponseCode `json:"code"`
        Message string       `json:"message"`
        Data    interface{}  `json:"data,omitempty"`
}

// ErrorResponse represents detailed error response
type ErrorResponse struct {
        HttpStatusCode int          `json:"-"`
        Code           ResponseCode `json:"code"`
        Message        string       `json:"message"`
        Details        interface{}  `json:"details,omitempty"`
        Source         string       `json:"-"` // For logging purposes only, not returned to client
}

func (e *ErrorResponse) Error() string <span class="cov0" title="0">{
        if e.Details != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.Message, e.Details)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package response

type ResponseCode uint64

const baseResponseCode uint64 = 10000

func newResponseCode(code uint64) ResponseCode <span class="cov0" title="0">{
        return ResponseCode(baseResponseCode + code)
}</span>

var (
        // Success codes
        Success = newResponseCode(200)

        // 4xx Client Error codes
        ErrCodeNotFound         = newResponseCode(404)
        ErrCodeBadRequest       = newResponseCode(400)
        ErrCodeUnauthorized     = newResponseCode(401)
        ErrCodeForbidden        = newResponseCode(403)
        ErrCodeValidationFailed = newResponseCode(422)

        // &gt;5xx Server Error codes
        ErrCodeInternalServer     = newResponseCode(500)
        ErrCodeServiceUnavailable = newResponseCode(503)
        ErrCodeDatabaseError      = newResponseCode(600)
        ErrCodeUnknownError       = newResponseCode(700)
)

var CustomResponseMessages = map[ResponseCode]string{
        // Success codes
        Success: "Request completed successfully",

        // Client Error codes
        ErrCodeNotFound:         "Not Found",
        ErrCodeBadRequest:       "Bad Request",
        ErrCodeUnauthorized:     "Unauthorized",
        ErrCodeForbidden:        "Forbidden",
        ErrCodeValidationFailed: "Validation Failed",

        // Server Error codes
        ErrCodeInternalServer:     "Internal Server Error",
        ErrCodeServiceUnavailable: "Service Unavailable",
        ErrCodeDatabaseError:      "Database Error",
        ErrCodeUnknownError:       "Unknown Error",
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package routes

import (
        authHandler "github.com/Testzyler/banking-api/app/features/auth/handler"
        authRepository "github.com/Testzyler/banking-api/app/features/auth/repository"
        authService "github.com/Testzyler/banking-api/app/features/auth/service"

        homeHandler "github.com/Testzyler/banking-api/app/features/home/handler"
        homeRepository "github.com/Testzyler/banking-api/app/features/home/repository"
        homeService "github.com/Testzyler/banking-api/app/features/home/service"
        "github.com/Testzyler/banking-api/config"

        "github.com/Testzyler/banking-api/database"
        "github.com/gofiber/fiber/v2"
)

func InitHandlers(api fiber.Router, db database.DatabaseInterface, redisDB *database.RedisDatabase) <span class="cov0" title="0">{
        // Register Home handler with AuthMiddleware protection
        homeHandler.NewHomeHandler(
                api,
                homeService.NewHomeService(
                        homeRepository.NewHomeRepository(database.GetDatabase().GetDB()),
                ),
        )

        // Register Auth handler
        authRepo := authRepository.NewAuthRepository(database.GetDatabase().GetDB(), database.GetCache())
        jwtService := authService.NewJwtService(config.GetConfig(), authRepo)
        authHandler.NewAuthHandler(
                api,
                authService.NewAuthService(
                        authRepo,
                        jwtService,
                        config.GetConfig(),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package server

import (
        "context"
        "time"

        "github.com/Testzyler/banking-api/config"
        "github.com/Testzyler/banking-api/database"
        "github.com/Testzyler/banking-api/logger"
        "github.com/Testzyler/banking-api/server/exception"
        "github.com/Testzyler/banking-api/server/middlewares"
        "github.com/Testzyler/banking-api/server/response"
        handlers "github.com/Testzyler/banking-api/server/routes"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/recover"
)

type Server struct {
        App            *fiber.App
        Config         *config.Config
        DB             database.DatabaseInterface
        Cache          *database.RedisDatabase
        isShuttingDown bool
}

func NewServer(ctx context.Context, config *config.Config) *Server <span class="cov0" title="0">{
        app := fiber.New(fiber.Config{
                DisableStartupMessage: true,
                ReadTimeout:           config.Server.ReadTimeout,
                WriteTimeout:          config.Server.WriteTimeout,
                IdleTimeout:           config.Server.IdleTimeout,
                Concurrency:           config.Server.MaxConnections * 256 * 1024,
                ErrorHandler:          middlewares.ErrorHandler(), // Use the new error handler middleware
        })

        err := database.InitDatabase(config)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to database", "error", err)
        }</span>

        <span class="cov0" title="0">err = database.InitCache(config.Cache)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to connect to cache", "error", err)
        }</span>

        <span class="cov0" title="0">db := database.GetDatabase()
        cache := database.GetCache()
        server := &amp;Server{
                App:            app,
                Config:         config,
                DB:             db,
                Cache:          cache,
                isShuttingDown: false,
        }

        server.setupMiddleware()
        server.setupRoutes()

        return server</span>
}

// Middleware
func (s *Server) setupMiddleware() <span class="cov0" title="0">{
        // Request ID middleware
        s.App.Use(middlewares.RequestIDMiddleware())

        // Logger middleware
        s.App.Use(middlewares.LoggerMiddleware())

        // Recovery middleware
        s.App.Use(recover.New())

        // CORS middleware
        s.App.Use(cors.New(cors.Config{
                AllowOrigins: "*",
                AllowMethods: "GET,POST,HEAD,PUT,DELETE,PATCH,OPTIONS",
                AllowHeaders: "*",
        }))
}</span>

func (s *Server) setupRoutes() <span class="cov0" title="0">{
        // Health check
        s.App.Get("/healthz", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                if s.isShuttingDown </span><span class="cov0" title="0">{
                        return exception.ErrServiceUnavailable
                }</span>

                <span class="cov0" title="0">healthData := map[string]interface{}{
                        "status":    "healthy",
                        "timestamp": time.Now(),
                }

                return c.JSON(&amp;response.SuccessResponse{
                        Code:    response.Success,
                        Message: "Service is healthy",
                        Data:    healthData,
                })</span>
        })
        // API routes
        <span class="cov0" title="0">api := s.App.Group("/api/v1")

        // Initialize handlers
        handlers.InitHandlers(api, s.DB, s.Cache)

        // Setup 404 handler
        s.App.Use(middlewares.NotFoundHandler)</span>
}

func (s *Server) Start() error <span class="cov0" title="0">{
        if err := s.App.Listen(":" + s.Config.Server.Port); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Server) Shutdown() error <span class="cov0" title="0">{
        var shutdownErrors []error
        s.isShuttingDown = true

        // Shut down the Fiber application
        if err := s.App.Shutdown(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error shutting down HTTP server", "error", err)
                shutdownErrors = append(shutdownErrors, err)
        }</span> else<span class="cov0" title="0"> {
                logger.Info("HTTP server shutdown successfully")
        }</span>

        // Close database connections
        <span class="cov0" title="0">if s.DB != nil </span><span class="cov0" title="0">{
                if err := s.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error closing database", "error", err)
                        shutdownErrors = append(shutdownErrors, err)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Database connections closed successfully")
                }</span>
        }

        // Return first error if any occurred
        <span class="cov0" title="0">if len(shutdownErrors) &gt; 0 </span><span class="cov0" title="0">{
                return shutdownErrors[0]
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
